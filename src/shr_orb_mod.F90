module SHR_ORB_MOD
  use shr_kind_mod, only: SHR_KIND_R8, SHR_KIND_IN, SHR_KIND_I4
  ! this gives too many issues to test locally
  ! use shr_sys_mod, only: shr_sys_abort
  use shr_const_mod, only: shr_const_pi
  ! use shr_log_mod, only: shr_log_getLogUnit
  use shr_log_mod, only: shr_log_unit, shr_log_getLogUnit

  implicit none

  !----------------------------------------------------------------------------
  ! PUBLIC: Interfaces and global data
  !----------------------------------------------------------------------------
  ! Deleted these from main function for testing purposes!
  !  public :: shr_orb_azimuth
  !  public :: shr_orb_cosinc
  !  public :: shr_orb_cosz
  public :: shr_orb_params
  ! Deleted these from main function for testing purposes!
  ! public :: shr_orb_decl
  ! public :: shr_orb_print
  ! public :: set_constant_zenith_angle_deg

  real   (SHR_KIND_R8),public,parameter :: SHR_ORB_UNDEF_REAL = 1.e36_SHR_KIND_R8 ! undefined real
  integer(SHR_KIND_IN),public,parameter :: SHR_ORB_UNDEF_INT  = 2000000000        ! undefined int

  !----------------------------------------------------------------------------
  ! PRIVATE: by default everything else is private to this module
  !----------------------------------------------------------------------------
  private

  real   (SHR_KIND_R8),parameter :: pi                 = SHR_CONST_PI
  real   (SHR_KIND_R8),parameter :: SHR_ORB_ECCEN_MIN  =   0.0_SHR_KIND_R8 ! min value for eccen
  real   (SHR_KIND_R8),parameter :: SHR_ORB_ECCEN_MAX  =   0.1_SHR_KIND_R8 ! max value for eccen
  real   (SHR_KIND_R8),parameter :: SHR_ORB_OBLIQ_MIN  = -90.0_SHR_KIND_R8 ! min value for obliq
  real   (SHR_KIND_R8),parameter :: SHR_ORB_OBLIQ_MAX  = +90.0_SHR_KIND_R8 ! max value for obliq
  real   (SHR_KIND_R8),parameter :: SHR_ORB_MVELP_MIN  =   0.0_SHR_KIND_R8 ! min value for mvelp
  real   (SHR_KIND_R8),parameter :: SHR_ORB_MVELP_MAX  = 360.0_SHR_KIND_R8 ! max value for mvelp

  ! commented out because not needed for local dev.
  ! ! This variable overrides the behavior of shr_orb_cosz() when >=0
  ! ! this is be set by calling set_constant_zenith_angle_deg()
  ! real   (SHR_KIND_R8) :: constant_zenith_angle_deg = -1  ! constant, uniform zneith angle [degrees]

  !===============================================================================
contains
  !===============================================================================

  !===============================================================================
  ! New Insolation Forcing for Paleoclimate Studies
  ! Kocken, I.J. and Zeebe, R.E. (2025). ESS Open Archive.
  ! doi: 10.22541/essoar.175511741.18639670
  ! https://github.com/japhir/paleoinsolation
  !===============================================================================

  !> Read input from out.dat, generated by snvec
  subroutine readdata(pt_solution_file, time, ecc, obl, prec, lpx, climprec)
    real(SHR_KIND_R8), intent(out), allocatable :: time(:), ecc(:), obl(:), prec(:), lpx(:), climprec(:)
    integer(SHR_KIND_IN) :: io, ios, i, n
    character(len=*), intent(in) :: pt_solution_file
    character(len=512) :: msg
    open(newunit=io,file=pt_solution_file, status = "old", action = "read", &
         iostat=ios, iomsg = msg)
    ! check if file exists/contains anything
    if (ios /= 0) then
       print *, trim(msg)
    else
       ! find the number of lines in the file
       n = 0
       do
          read(io,*,iostat=ios)
          if (ios/=0) then
             rewind(io)
             exit
          else
             n=n+1
          end if
       end do
       allocate(time(n),ecc(n),obl(n),prec(n),lpx(n),climprec(n))
       do i=1,n
          read(io,*) time(i), ecc(i), obl(i), prec(i), lpx(i), climprec(i)
       enddo
    end if
    close(io)
  end subroutine readdata

  !===============================================================================

  subroutine readbindata(pt_solution_file, time, ecc, obl, prec, lpx, climprec)
    real(SHR_KIND_R8), intent(out), allocatable :: time(:), ecc(:), obl(:), prec(:), lpx(:), climprec(:)
    character(len=*), intent(in) :: pt_solution_file
    ! note that this must be the below Int32 type!
    integer(SHR_KIND_I4) :: n

    ! Read kount as 4-byte integer
    ! Open the binary file in stream mode
    open(unit=10, file=pt_solution_file, access='stream', form='unformatted', status='old', action='read')
    read(10) n
    allocate(time(n), ecc(n), obl(n), prec(n), lpx(n), climprec(n))
    ! Read each array
    read(10) time
    read(10) ecc
    read(10) obl
    read(10) prec
    read(10) lpx
    read(10) climprec
    close(10)

    ! Convert time from days to kyr
    time = time / 365250.0_SHR_KIND_R8
  end subroutine readbindata

  !===============================================================================

  !> Write output to ins_file
  subroutine writedata(ins_file, time, ecc, obl, prec, lpx, climprec, ins)
    real(SHR_KIND_R8), intent(in), dimension(:) :: time, ecc, obl, prec, lpx, climprec, ins
    integer(SHR_KIND_IN) :: i,n
    character(len=*) :: ins_file
    n = size(time)
    open (unit=42, file=ins_file, status="replace", action="write")
    do i=1,n
       write(42,*) time(i), ecc(i), obl(i), prec(i), lpx(i), climprec(i), ins(i)
    enddo
    close(42)
  end subroutine writedata

  !===============================================================================

  ! Below interpolation function adapted from
  ! https://github.com/astrofrog/fortranlib/blob/master/src/lib_array.f90
  ! repeat of their copyright notice follows:
  !
  ! MD5 of template: 13982be359376d65d4f966553ef27636
  ! Array related routines (Integration, Interpolation, etc.)
  !
  ! ------------------------------------------------------------------------------
  ! Copyright (c) 2009-13, Thomas P. Robitaille
  !
  ! All rights reserved.
  !
  ! Redistribution and use in source and binary forms, with or without
  ! modification, are permitted provided that the following conditions are met:
  !
  !  * Redistributions of source code must retain the above copyright notice, this
  !    list of conditions and the following disclaimer.
  !
  !  * Redistributions in binary form must reproduce the above copyright notice,
  !    this list of conditions and the following disclaimer in the documentation
  !    and/or other materials provided with the distribution.
  !
  ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  ! ------------------------------------------------------------------------------
  ! locate_dp
  integer function locate(xx,x)
    ! Locate a value in a sorted array
    real(SHR_KIND_R8), dimension(:), intent(in) :: xx
    real(SHR_KIND_R8), intent(in) :: x
    integer(SHR_KIND_IN) :: n,jl,jm,ju
    logical :: ascnd
    n=size(xx)
    ascnd = (xx(n) >= xx(1))
    jl=0
    ju=n+1
    do
       if (ju-jl <= 1) exit
       jm=(ju+jl)/2
       if (ascnd .eqv. (x >= xx(jm))) then
          jl=jm
       else
          ju=jm
       end if
    end do

    if (x == xx(1)) then
       locate = 1
    else if (x == xx(n)) then
       locate = n-1
    else if(ascnd.and. (x > xx(n) .or. x < xx(1))) then
       locate = -1
    else if(.not.ascnd.and. (x < xx(n) .or. x > xx(1))) then
       locate = -1
    else
       locate = jl
    end if
  end function locate

  !===============================================================================

  subroutine shr_orb_params( iyear_AD, eccen, obliq, mvelp, &
       & obliqr, lambm0, mvelpp, log_print )

    !-------------------------------------------------------------------------------
    ! Calculate earths orbital parameters by interpolating recent astronomical
    ! solution ZB18a(1,1) or ZB20a(1,1).
    !
    ! ZB18a:
    !  Zeebe, R. E., & Lourens, L. J. (2019). Solar System chaos and the
    !  Paleocene–Eocene boundary age constrained by geology and
    !  astronomy. _Science_, 365(6456), 926–929.
    !  doi:10.1126/science.aax0612
    !  <https://doi.org/10.1126/science.aax0612>.'
    !
    ! ZB20a:
    !  Zeebe, R. E. and Lourens, L. J. (2022). Geologically constrained
    !  astronomical solutions for the Cenozoic era. _Earth and Planetary
    !  Science Letters_. doi:10.1016/j.epsl.2022.117595
    !  <https://doi.org/10.1016/j.epsl.2022.117595>
    !
    ! This code is hosted on:
    ! https://github.com/japhir/paleoinsolation
    ! And is permanently archived on:
    ! Kocken, I. J. (2025) paleoinsolation: New Insolation Forcing for Paleoclimate Models
    ! Zenodo. https://doi.org/10.5281/zenodo.17478418
    !
    !------------------------------Code history-------------------------------------
    !
    ! First version that relied on Berger 1978 orbital solution:
    ! Original Author: Erik Kluzek
    ! Date:            Oct/97
    ! Major overhaul to support ZB18a(1,1) and ZB20a(1,1) orbital solutions:
    ! Author:          Ilja J. Kocken
    ! Date:            2025-11-06
    !
    !-------------------------------------------------------------------------------

    !----------------------------- Arguments ------------------------------------
    integer(SHR_KIND_IN),intent(in)    :: iyear_AD  ! Year to calculate orbit for
    real   (SHR_KIND_R8),intent(inout) :: eccen     ! orbital eccentricity
    real   (SHR_KIND_R8),intent(inout) :: obliq     ! obliquity in degrees
    real   (SHR_KIND_R8),intent(inout) :: mvelp     ! moving vernal equinox long
    real   (SHR_KIND_R8),intent(out)   :: obliqr    ! Earths obliquity in rad
    real   (SHR_KIND_R8),intent(out)   :: lambm0    ! Mean long of perihelion at
    ! vernal equinox (radians)
    real   (SHR_KIND_R8),intent(out)   :: mvelpp    ! moving vernal equinox long
    ! of perihelion plus pi (rad)
    logical             ,intent(in)    :: log_print ! Flags print of status/error

    !------------------------------ Parameters ----------------------------------
    real   (SHR_KIND_R8) :: degrad = pi/180._SHR_KIND_R8   ! degree to radian conversion factor
    real   (SHR_KIND_R8) :: yb4_J2000         ! number of years before J2000.0

    character(len=*),parameter :: subname = '(shr_orb_params)'
    !---------------------------Local variables----------------------------------
    real(SHR_KIND_R8), dimension(:), allocatable :: times, eccs, obls, precs, lpxs, climprecs
    real   (SHR_KIND_R8) :: frac, time_kyr
    integer(SHR_KIND_IN) :: n, ipos
    real   (SHR_KIND_R8) :: beta    ! Intermediate argument for lambm0
    real   (SHR_KIND_R8) :: eccen2  ! eccentricity squared
    real   (SHR_KIND_R8) :: eccen3  ! eccentricity cubed
    integer              :: s_logunit
    !-------------------------- Formats -----------------------------------------
    character(len=*),parameter :: F00 = "('(shr_orb_params) ',4a)"
    character(len=*),parameter :: F01 = "('(shr_orb_params) ',a,i9)"
    character(len=*),parameter :: F02 = "('(shr_orb_params) ',a,f6.3)"
    character(len=*),parameter :: F03 = "('(shr_orb_params) ',a,es14.6)"

    !----------------------------------------------------------------------------
    ! radinp and algorithms below will need a degree to radian conversion factor
    call shr_log_getLogUnit(s_logunit)
    if ( log_print ) then
       write(s_logunit,F00) 'Calculate characteristics of the orbit:'
    end if

    ! Check for flag to use input orbit parameters

    IF ( iyear_AD == SHR_ORB_UNDEF_INT ) THEN

       ! Check input obliq, eccen, and mvelp to ensure reasonable

       if( obliq == SHR_ORB_UNDEF_REAL )then
          write(s_logunit,F00) trim(subname)//' Have to specify orbital parameters:'
          write(s_logunit,F00) 'Either set: iyear_AD, OR [obliq, eccen, and mvelp]:'
          write(s_logunit,F00) 'iyear_AD is the year to simulate orbit for (ie. 1950): '
          write(s_logunit,F00) 'obliq, eccen, mvelp specify the orbit directly:'
          write(s_logunit,F00) 'The AMIP II settings (for a 1995 orbit) are: '
          write(s_logunit,F00) ' obliq =  23.4441'
          write(s_logunit,F00) ' eccen =   0.016715'
          write(s_logunit,F00) ' mvelp = 102.7'
          ! commented out so that I don't have to introduce dependency on shr_sys_mod and shr_abort_mod
!!$          call shr_sys_abort(subname//' ERROR: unreasonable obliq')

          error stop
       else if ( log_print ) then
          write(s_logunit,F00) 'Use input orbital parameters: '
       end if
       if( (obliq < SHR_ORB_OBLIQ_MIN).or.(obliq > SHR_ORB_OBLIQ_MAX) ) then
          write(s_logunit,F03) 'Input obliquity unreasonable: ', obliq
!!$          call shr_sys_abort(subname//' ERROR: unreasonable obliq')
          error stop
       end if
       if( (eccen < SHR_ORB_ECCEN_MIN).or.(eccen > SHR_ORB_ECCEN_MAX) ) then
          write(s_logunit,F03) 'Input eccentricity unreasonable: ', eccen
          error stop
!!$          call shr_sys_abort(subname//' ERROR: unreasonable eccen')
       end if
       if( (mvelp < SHR_ORB_MVELP_MIN).or.(mvelp > SHR_ORB_MVELP_MAX) ) then
          write(s_logunit,F03) 'Input mvelp unreasonable: ' , mvelp
          error stop
!!$          call shr_sys_abort(subname//' ERROR: unreasonable mvelp')
       end if
       ! calculate obliquity in radians
       obliqr = obliq*degrad
    ELSE  ! Otherwise calculate based on years before present

       ! this is the model year in kyr for interpolation
       yb4_J2000 = (real(iyear_AD,SHR_KIND_R8) - 2000.0_SHR_KIND_R8)
       time_kyr = yb4_J2000*1.0e-3_SHR_KIND_R8

       if ( log_print ) then
          write(s_logunit,F01) 'Calculate orbit for year: ' , iyear_AD
          write(s_logunit,F03) 'Model time in kyr: ' , time_kyr
       end if

       if ((time_kyr .lt. -300000.0_SHR_KIND_R8) .or. (time_kyr .gt. 0.0_SHR_KIND_R8))then
          write(s_logunit,F00) 'orbit only available for years -300,000,000 to 0'
          write(s_logunit,F00) 'Relative to J2000.0'
          write(s_logunit,F03) '# of years before J2000: ',yb4_J2000
          write(s_logunit,F01) 'Year to simulate was  :  ',iyear_AD
          error stop
!!$          call shr_sys_abort(subname//' ERROR: unreasonable year')
       end if
       ! TODO: you could comment out either of these checks, depending on which solution you use
       if ( time_kyr .lt. -58000.0_SHR_KIND_R8)then
          write(s_logunit,F00) 'Caution: For ZB18a, the interval -300 Myr to -58 Myr is unconstrained due to solar system chaos.'
       end if
       if ( time_kyr .lt. -71000.0_SHR_KIND_R8)then
          write(s_logunit,F00) 'Caution: For ZB20a, the interval -300 Myr to -71 Myr is unconstrained due to solar system chaos.'
       end if
       ! get orbital solution ZB18a(1,1) or ZB20a(1,1)
       ! TODO: update this line to your liking!
       call readdata('dat/PT-ZB18a_1-1.dat', times, eccs, obls, precs, lpxs, climprecs)
       !call readdata('/path/to/my_cesm_sandbox/orb/dat/PT-ZB18a_1-1.dat', times, eccs, obls, precs, lpxs, climprecs) ! update path
       !call readdata('dat/PT-ZB20a_1-1.dat', times, eccs, obls, precs, lpxs, climprecs) ! update solution
       !call readbindata('dat/PT-ZB20a_1-1.bin', times, eccs, obls, precs, lpxs, climprecs) ! use binary files
       n = size(times)

       ! the DE431 ephimerides used for the ZB18a solution
       ! has t0 = Julian day 2443144.5003725 (Folkner et al., 2014)
       ! this is approximately 1977-01-01 at 00:00:32 (web tool conversion)
       ! However, t0 was set to J2000.0 when initial conditions were calculated.
       ! also: model years are negative, but yearCE is positive

       ipos = locate(times,time_kyr)
       if(ipos == -1) then
          write(s_logunit,F00) 'interpolation of orbital solution failed.'
          write(s_logunit,F03) 'requested time_kyr: ',time_kyr
          write(s_logunit,F03) 'time at t0: ',times(1)
          write(s_logunit,F03) 'time at tfinal',times(n)
          error stop
!!$          call shr_sys_abort(subname//' ERROR: Interpolation out of bounds')
       end if

       frac = ( time_kyr - times(ipos) ) / ( times(ipos+1) - times(ipos) )

       eccen = eccs(ipos) + frac * (eccs(ipos+1) - eccs(ipos))
       obliqr = obls(ipos) + frac * (obls(ipos+1) - obls(ipos))
       ! prec = linear_interpolation(times,precs,time_kyr)
       ! snvec currently provides this in radians, convert to degrees for consistency
       mvelp = (lpxs(ipos) + frac * (lpxs(ipos+1) - lpxs(ipos))) / degrad

       ! Cases to make sure mvelp is between 0 and 360.

       do while (mvelp .lt. 0.0_SHR_KIND_R8)
          mvelp = mvelp + 360.0_SHR_KIND_R8
       end do
       do while (mvelp .ge. 360.0_SHR_KIND_R8)
          mvelp = mvelp - 360.0_SHR_KIND_R8
       end do
       ! calculate obliquity in degrees
       obliq = obliqr / degrad

    END IF  ! end of test on whether to calculate or use input orbital params

    ! 180 degrees must be added to mvelp since observations are made from the
    ! earth and the sun is considered (wrongly for the algorithm) to go around
    ! the earth. For a more graphic explanation see Appendix B in:
    !
    ! A. Berger, M. Loutre and C. Tricot. 1993.  Insolation and Earth Orbital
    ! Periods.  J. of Geophysical Research 98:10,341-10,362.
    !
    ! Additionally, orbit will need this value in radians. So mvelp becomes
    ! mvelpp (mvelp plus pi)

    mvelpp = (mvelp + 180._SHR_KIND_R8)*degrad

    ! Set up arguments used several times in lambm0 calculation ahead.

    eccen2 = eccen*eccen
    eccen3 = eccen2*eccen
    beta = sqrt(1._SHR_KIND_R8 - eccen2)

    ! The mean longitude at the vernal equinox (lambda m nought in Berger
    ! 1978; in radians) is calculated from the following formula given in
    ! Berger 1978.  At the vernal equinox the true longitude (lambda in Berger
    ! 1978) is 0.

    lambm0 = 2._SHR_KIND_R8*((.5_SHR_KIND_R8*eccen + .125_SHR_KIND_R8*eccen3)*(1._SHR_KIND_R8 + beta)*sin(mvelpp)  &
         &      - .250_SHR_KIND_R8*eccen2*(.5_SHR_KIND_R8    + beta)*sin(2._SHR_KIND_R8*mvelpp)            &
         &      + .125_SHR_KIND_R8*eccen3*(1._SHR_KIND_R8/3._SHR_KIND_R8 + beta)*sin(3._SHR_KIND_R8*mvelpp))

    if ( log_print ) then
       write(s_logunit,F03) '------ Computed Orbital Parameters ------'
       write(s_logunit,F03) 'Eccentricity      = ',eccen
       write(s_logunit,F03) 'Obliquity (deg)   = ',obliq
       write(s_logunit,F03) 'Obliquity (rad)   = ',obliqr
       write(s_logunit,F03) 'Long of perh(deg) = ',mvelp
       write(s_logunit,F03) 'Long of perh(rad) = ',mvelpp
       write(s_logunit,F03) 'Long at v.e.(rad) = ',lambm0
       write(s_logunit,F03) '-----------------------------------------'
    end if

  END SUBROUTINE shr_orb_params

end module shr_orb_mod
