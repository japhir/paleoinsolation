module interp
  use kind, only : dp
  use data, only : readdata

  implicit none

  private
  public :: orbpar
  public :: locate

contains

!> this should be a drop-in replacement for the GISS_ORBPAR function
!> available on https://data.giss.nasa.gov/modelE/ar5plots/srorbpar.html
!> (last accessed on 2024-12-17)
!> could be easily incorporated into https://github.com/CESM-Development/paleoToolkit/tree/master/PaleoCalAdjust
subroutine orbpar(yearCE,ecc,obl,lpx)
  real(dp), intent(in) :: yearCE
  real(dp), intent(out) :: ecc, obl, lpx

  ! SOME: figure out how to make this not read the data every time for each timestep
  ! maybe pass it optional parameters so if available, can use those instead?
  real(dp), dimension(:), allocatable :: times, eccs, obls, precs, lpxs, climprecs

  real(dp) :: pi
  real(dp) :: yearBP, time_kyr

  integer :: n, ipos
  real(dp) :: frac

  pi = 4.0_dp*datan(1.0_dp)
  ! this reads the file out.dat, generated by snvec
  ! SOME: change from reading plain-text to binary files?

  call readdata(times, eccs, obls, precs, lpxs, climprecs)
  n = size(times)
  ! re-wrap
  lpxs = modulo(lpxs - pi, 2.0_dp*pi)

  ! the DE431 ephimerides used for the ZB18a solution
  ! has t0 = Julian day 2443144.5003725
  ! this is approximately 1977-01-01 at 00:00:32
  ! so 0 model years = 1977 CE
  ! so to convert from CE to model years, subtract 1977
  ! also: model years are negative, but yearCE is positive

  ! this is the model year in kyr for interpolation
  time_kyr = -(yearCE - 1977.0_dp)*1.0e-3_dp
  ! yearBP = (yearCE - 1950.0_dp) ! yearBP is typically positive

  ipos = locate(times,time_kyr)
  if(ipos == -1) then
     write(0,'("ERROR: Interpolation out of bounds : ",ES11.4," in [",ES11.4,":",ES11.4,"]")') time_kyr,times(1),times(n)
  end if

  frac = ( time_kyr - times(ipos) ) / ( times(ipos+1) - times(ipos) )

  ecc = eccs(ipos) + frac * (eccs(ipos+1) - eccs(ipos))
  obl = obls(ipos) + frac * (obls(ipos+1) - obls(ipos))
  ! prec = linear_interpolation(times,precs,time_kyr)
  lpx = lpxs(ipos) + frac * (lpxs(ipos+1) - lpxs(ipos))
  ! climprec = linear_interpolation(times,climprec,time_kyr)
end subroutine orbpar

! adapted from https://github.com/astrofrog/fortranlib/blob/master/src/lib_array.f90
! locate_dp
integer function locate(xx,x)
  ! Locate a value in a sorted array
  real(dp), dimension(:), intent(in) :: xx
  real(dp), intent(in) :: x
  integer :: n,jl,jm,ju
  logical :: ascnd
  n=size(xx)
  ascnd = (xx(n) >= xx(1))
  jl=0
  ju=n+1
  do
     if (ju-jl <= 1) exit
     jm=(ju+jl)/2
     if (ascnd .eqv. (x >= xx(jm))) then
        jl=jm
     else
        ju=jm
     end if
  end do

  if (x == xx(1)) then
     locate = 1
  else if (x == xx(n)) then
     locate = n-1
  else if(ascnd.and. (x > xx(n) .or. x < xx(1))) then
     locate = -1
  else if(.not.ascnd.and. (x < xx(n) .or. x > xx(1))) then
     locate = -1
  else
     locate = jl
  end if
end function locate



end module interp
